# Phase 06.7: WebSocket Service

## Overview
Implement a robust WebSocket service for real-time communication between the Angular frontend and the backend gateway.

**Note**: This service is designed to match the backend's WebSocket contract defined in `CodeAgent.Gateway`. The backend uses:
- Capital-cased property names (C# convention): `Type`, `Payload`, `CorrelationId`
- Simple message types: `auth`, `chat`, `command`, `ping`, `pong`
- Response types with lowercase `type` property: `auth_response`, `chat_response`, etc.

## Objectives
- Establish WebSocket connection
- Handle connection lifecycle
- Implement message queuing
- Support reconnection logic
- Provide typed message handling

## Prerequisites
- Phase 06.1 (Project Setup) completed
- Phase 06.2 (Theme System) completed
- Backend WebSocket gateway running

## Implementation

### 1. Generate Service
```bash
ng generate service core/services/websocket --skipTests=false
```

### 2. WebSocket Models

`src/app/core/models/websocket.model.ts`:
```typescript
export enum WebSocketMessageType {
  // Core message types (matching backend)
  Auth = 'auth',
  Chat = 'chat',
  Command = 'command',
  Ping = 'ping',
  Pong = 'pong',
  Error = 'error',
  
  // Response types
  AuthResponse = 'auth_response',
  ChatResponse = 'chat_response',
  CommandResponse = 'command_response'
}

// Match backend's MessageEnvelope structure
export interface MessageEnvelope<T = any> {
  Type: string;  // Capital case to match backend C# conventions
  Payload?: T;   // JsonElement in backend, generic type in frontend
  CorrelationId?: string;
}

// For typed responses from backend
export interface ServerResponse {
  type: string;
  [key: string]: any;  // Additional properties vary by response type
}

// Specific response types
export interface AuthResponse {
  type: 'auth_response';
  success: boolean;
  sessionId: string;
}

export interface ErrorResponse {
  type: 'error';
  message: string;
}

export interface PingResponse {
  type: 'pong';
  timestamp: string;
}

export interface WebSocketConfig {
  url: string;
  reconnect: boolean;
  reconnectInterval: number;
  reconnectAttempts: number;
  heartbeatInterval: number;
}

export enum WebSocketState {
  Connecting = 'CONNECTING',
  Connected = 'CONNECTED',
  Disconnecting = 'DISCONNECTING',
  Disconnected = 'DISCONNECTED',
  Reconnecting = 'RECONNECTING'
}
```

### 3. WebSocket Service Implementation

`src/app/core/services/websocket.service.ts`:
```typescript
import { Injectable, OnDestroy } from '@angular/core';
import { 
  Subject, 
  Observable, 
  BehaviorSubject, 
  timer, 
  throwError,
  fromEvent,
  EMPTY
} from 'rxjs';
import { 
  retryWhen, 
  tap, 
  delayWhen, 
  filter,
  map,
  takeUntil,
  catchError
} from 'rxjs/operators';
import { 
  MessageEnvelope,
  ServerResponse,
  WebSocketMessageType, 
  WebSocketConfig,
  WebSocketState
} from '../models/websocket.model';

@Injectable({
  providedIn: 'root'
})
export class WebSocketService implements OnDestroy {
  private socket?: WebSocket;
  private config: WebSocketConfig = {
    url: 'ws://localhost:8080/ws',
    reconnect: true,
    reconnectInterval: 5000,
    reconnectAttempts: 5,
    heartbeatInterval: 30000
  };
  
  private messagesSubject = new Subject<ServerResponse>();
  private connectionStateSubject = new BehaviorSubject<WebSocketState>(
    WebSocketState.Disconnected
  );
  private destroy$ = new Subject<void>();
  private messageQueue: MessageEnvelope[] = [];
  private reconnectAttempt = 0;
  private heartbeatTimer?: any;
  
  public messages$ = this.messagesSubject.asObservable();
  public connectionState$ = this.connectionStateSubject.asObservable();
  
  constructor() {
    // Auto-connect on service creation
    this.connect();
  }
  
  ngOnDestroy() {
    this.disconnect();
    this.destroy$.next();
    this.destroy$.complete();
  }
  
  connect(url?: string): void {
    if (url) {
      this.config.url = url;
    }
    
    if (this.socket?.readyState === WebSocket.OPEN) {
      console.log('WebSocket already connected');
      return;
    }
    
    this.connectionStateSubject.next(WebSocketState.Connecting);
    
    try {
      this.socket = new WebSocket(this.config.url);
      this.setupSocketListeners();
    } catch (error) {
      console.error('WebSocket connection error:', error);
      this.handleReconnection();
    }
  }
  
  private setupSocketListeners(): void {
    if (!this.socket) return;
    
    this.socket.onopen = (event) => {
      console.log('WebSocket connected');
      this.connectionStateSubject.next(WebSocketState.Connected);
      this.reconnectAttempt = 0;
      this.flushMessageQueue();
      this.startHeartbeat();
    };
    
    this.socket.onmessage = (event) => {
      try {
        const response: ServerResponse = JSON.parse(event.data);
        
        // Handle pong messages internally
        if (response.type === 'pong') {
          return;
        }
        
        this.messagesSubject.next(response);
      } catch (error) {
        console.error('Error parsing WebSocket message:', error);
      }
    };
    
    this.socket.onerror = (error) => {
      console.error('WebSocket error:', error);
    };
    
    this.socket.onclose = (event) => {
      console.log('WebSocket disconnected', event);
      this.connectionStateSubject.next(WebSocketState.Disconnected);
      this.stopHeartbeat();
      
      if (this.config.reconnect && !event.wasClean) {
        this.handleReconnection();
      }
    };
  }
  
  private handleReconnection(): void {
    if (this.reconnectAttempt >= this.config.reconnectAttempts) {
      console.error('Max reconnection attempts reached');
      return;
    }
    
    this.reconnectAttempt++;
    this.connectionStateSubject.next(WebSocketState.Reconnecting);
    
    console.log(`Reconnecting... Attempt ${this.reconnectAttempt}`);
    
    setTimeout(() => {
      this.connect();
    }, this.config.reconnectInterval);
  }
  
  disconnect(): void {
    if (this.socket) {
      this.connectionStateSubject.next(WebSocketState.Disconnecting);
      this.config.reconnect = false;
      this.socket.close();
      this.socket = undefined;
      this.stopHeartbeat();
    }
  }
  
  send<T = any>(type: string, payload?: T, correlationId?: string): void {
    const message: MessageEnvelope<T> = {
      Type: type,
      Payload: payload,
      CorrelationId: correlationId
    };
    
    if (this.socket?.readyState === WebSocket.OPEN) {
      this.socket.send(JSON.stringify(message));
    } else {
      // Queue message for later delivery
      this.messageQueue.push(message);
      console.log('Message queued for delivery:', message);
    }
  }
  
  private flushMessageQueue(): void {
    while (this.messageQueue.length > 0) {
      const message = this.messageQueue.shift();
      if (message && this.socket?.readyState === WebSocket.OPEN) {
        this.socket.send(JSON.stringify(message));
      }
    }
  }
  
  private startHeartbeat(): void {
    this.stopHeartbeat();
    
    this.heartbeatTimer = setInterval(() => {
      if (this.socket?.readyState === WebSocket.OPEN) {
        // Match backend's ping format
        const pingMessage = JSON.stringify({ type: 'ping' });
        this.socket.send(pingMessage);
      }
    }, this.config.heartbeatInterval);
  }
  
  private stopHeartbeat(): void {
    if (this.heartbeatTimer) {
      clearInterval(this.heartbeatTimer);
      this.heartbeatTimer = undefined;
    }
  }
  
  // Observable for specific response types
  on<T extends ServerResponse = ServerResponse>(type: string): Observable<T> {
    return this.messages$.pipe(
      filter(message => message.type === type),
      map(message => message as T)
    );
  }
  
  // Request-response pattern with correlation ID
  request<TRequest, TResponse extends ServerResponse>(
    type: string, 
    payload?: TRequest
  ): Observable<TResponse> {
    const correlationId = this.generateId();
    
    // Send the request with correlation ID
    this.send(type, payload, correlationId);
    
    // Wait for correlated response (backend should echo correlationId)
    return this.messages$.pipe(
      filter(msg => (msg as any).correlationId === correlationId),
      map(msg => msg as TResponse),
      takeUntil(timer(30000)) // 30 second timeout
    );
  }
  
  private generateId(): string {
    return `${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
  }
  
  isConnected(): boolean {
    return this.socket?.readyState === WebSocket.OPEN;
  }
  
  getConnectionState(): WebSocketState {
    return this.connectionStateSubject.value;
  }
}
```

### 4. WebSocket Interceptor

`src/app/core/interceptors/websocket-auth.interceptor.ts`:
```typescript
import { Injectable } from '@angular/core';
import { WebSocketService } from '../services/websocket.service';
import { WebSocketMessageType } from '../models/websocket.model';

@Injectable()
export class WebSocketAuthInterceptor {
  constructor(private wsService: WebSocketService) {
    this.setupAuthHandling();
  }
  
  private setupAuthHandling(): void {
    // Listen for connection events
    this.wsService.connectionState$.subscribe(state => {
      if (state === 'CONNECTED') {
        this.authenticate();
      }
    });
  }
  
  private authenticate(): void {
    const token = localStorage.getItem('auth_token');
    if (token) {
      // Send auth message matching backend's expected format
      this.wsService.send('auth', {
        token,
        clientId: this.getClientId()
      });
    }
  }
  
  private getClientId(): string {
    let clientId = localStorage.getItem('client_id');
    if (!clientId) {
      clientId = `client-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
      localStorage.setItem('client_id', clientId);
    }
    return clientId;
  }
}
```

## Usage Examples

### Component Usage
```typescript
import { Component, OnInit, OnDestroy } from '@angular/core';
import { Subject } from 'rxjs';
import { takeUntil } from 'rxjs/operators';
import { WebSocketService } from '@core/services/websocket.service';
import { AuthResponse, ChatResponse } from '@core/models/websocket.model';

@Component({
  selector: 'app-dashboard',
  template: `
    <div class="connection-status" [class.connected]="isConnected">
      {{ connectionStatus }}
    </div>
    <div class="session-info" *ngIf="sessionId">
      Session: {{ sessionId }}
    </div>
  `
})
export class DashboardComponent implements OnInit, OnDestroy {
  private destroy$ = new Subject<void>();
  isConnected = false;
  connectionStatus = 'Disconnected';
  sessionId: string | null = null;
  
  constructor(private wsService: WebSocketService) {}
  
  ngOnInit() {
    // Monitor connection state
    this.wsService.connectionState$
      .pipe(takeUntil(this.destroy$))
      .subscribe(state => {
        this.connectionStatus = state;
        this.isConnected = state === 'CONNECTED';
      });
    
    // Listen for auth responses
    this.wsService.on<AuthResponse>('auth_response')
      .pipe(takeUntil(this.destroy$))
      .subscribe(response => {
        if (response.success) {
          this.sessionId = response.sessionId;
        }
      });
    
    // Send auth message
    this.wsService.send('auth', {
      token: localStorage.getItem('auth_token')
    });
    
    // Send a chat message
    this.wsService.send('chat', {
      message: 'Hello from Angular!'
    });
  }
  
  ngOnDestroy() {
    this.destroy$.next();
    this.destroy$.complete();
  }
}
```

## Testing

### Unit Test
```typescript
describe('WebSocketService', () => {
  let service: WebSocketService;
  let mockWebSocket: jasmine.SpyObj<WebSocket>;
  
  beforeEach(() => {
    TestBed.configureTestingModule({});
    service = TestBed.inject(WebSocketService);
    
    // Mock WebSocket
    mockWebSocket = jasmine.createSpyObj('WebSocket', ['send', 'close']);
    spyOn(window, 'WebSocket').and.returnValue(mockWebSocket as any);
  });
  
  it('should be created', () => {
    expect(service).toBeTruthy();
  });
  
  it('should connect to WebSocket', () => {
    service.connect('ws://test.com');
    expect(window.WebSocket).toHaveBeenCalledWith('ws://test.com');
  });
  
  it('should send messages when connected', () => {
    mockWebSocket.readyState = WebSocket.OPEN;
    service.send('ping');
    expect(mockWebSocket.send).toHaveBeenCalled();
  });
  
  it('should queue messages when disconnected', () => {
    mockWebSocket.readyState = WebSocket.CLOSED;
    service.send('ping');
    expect(mockWebSocket.send).not.toHaveBeenCalled();
  });
  
  it('should format message with correct structure', () => {
    mockWebSocket.readyState = WebSocket.OPEN;
    service.send('auth', { token: 'test-token' });
    
    const sentMessage = JSON.parse(mockWebSocket.send.calls.mostRecent().args[0]);
    expect(sentMessage.Type).toBe('auth');
    expect(sentMessage.Payload).toEqual({ token: 'test-token' });
  });
  
  it('should emit connection state changes', (done) => {
    service.connectionState$.subscribe(state => {
      if (state === 'CONNECTING') {
        done();
      }
    });
    service.connect();
  });
});
```

## Deliverables
- [ ] WebSocket service created
- [ ] Connection management implemented
- [ ] Message queuing works
- [ ] Reconnection logic functional
- [ ] Heartbeat mechanism active
- [ ] Typed message handling
- [ ] Request-response pattern supported
- [ ] Unit tests passing

## Next Steps
- Implement API Service (06.8)
- Create Theme Service (06.9)