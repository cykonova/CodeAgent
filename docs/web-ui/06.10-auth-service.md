# Phase 06.11: Auth Service

## Overview
Create a comprehensive authentication service that handles user authentication, authorization, session management, and token handling.

## Objectives
- Manage user authentication state
- Handle login/logout operations
- Manage JWT tokens
- Implement session persistence
- Support role-based access control

## Prerequisites
- Phase 06.1 (Project Setup) completed
- Phase 06.7 (WebSocket Service) completed
- Angular Router configured

## Implementation

### 1. Generate Service
```bash
ng generate service core/services/auth --skipTests=false
```

### 2. Authentication Models

```typescript
// User model
export interface User {
  id: string;
  email: string;
  firstName: string;
  lastName: string;
  displayName: string;
  avatar?: string;
  roles: string[];
  permissions: string[];
  createdAt: Date;
  lastLogin: Date;
  emailVerified: boolean;
  metadata?: Record<string, any>;
}

// Authentication tokens
export interface AuthTokens {
  accessToken: string;
  refreshToken?: string;
  expiresIn: number;
  tokenType: string;
}

// Login credentials
export interface LoginCredentials {
  email: string;
  password: string;
  rememberMe?: boolean;
}

// Registration data
export interface RegistrationData {
  email: string;
  password: string;
  firstName: string;
  lastName: string;
  acceptTerms: boolean;
}

// Auth response
export interface AuthResponse {
  user: User;
  tokens: AuthTokens;
  sessionId: string;
}

// Auth state
export interface AuthState {
  isAuthenticated: boolean;
  user: User | null;
  tokens: AuthTokens | null;
  loading: boolean;
  error: string | null;
}
```

### 3. Auth Service Implementation

#### Core Service Structure
```typescript
@Injectable({
  providedIn: 'root'
})
export class AuthService implements OnDestroy {
  private readonly TOKEN_KEY = 'auth_token';
  private readonly REFRESH_TOKEN_KEY = 'refresh_token';
  private readonly USER_KEY = 'auth_user';
  
  private authStateSubject = new BehaviorSubject<AuthState>({
    isAuthenticated: false,
    user: null,
    tokens: null,
    loading: false,
    error: null
  });
  
  private tokenRefreshTimer?: any;
  private destroy$ = new Subject<void>();
  
  public authState$ = this.authStateSubject.asObservable();
  public isAuthenticated$ = this.authState$.pipe(map(state => state.isAuthenticated));
  public currentUser$ = this.authState$.pipe(map(state => state.user));
  public loading$ = this.authState$.pipe(map(state => state.loading));
  
  constructor(
    private wsService: WebSocketService,
    private router: Router,
    private snackBar: MatSnackBar
  ) {
    this.initializeAuth();
  }
  
  ngOnDestroy(): void {
    this.clearTokenRefreshTimer();
    this.destroy$.next();
    this.destroy$.complete();
  }
}
```

#### Authentication Initialization
```typescript
private initializeAuth(): void {
  // Check for existing session
  const token = this.getStoredToken();
  const user = this.getStoredUser();
  
  if (token && user) {
    // Validate token
    if (this.isTokenValid(token)) {
      this.setAuthState({
        isAuthenticated: true,
        user,
        tokens: { accessToken: token } as AuthTokens,
        loading: false,
        error: null
      });
      
      // Set up token refresh
      this.scheduleTokenRefresh();
      
      // Connect WebSocket
      this.connectWebSocket();
    } else {
      // Token expired, try to refresh
      this.refreshToken();
    }
  }
}

private isTokenValid(token: string): boolean {
  try {
    const payload = this.decodeToken(token);
    const expirationTime = payload.exp * 1000; // Convert to milliseconds
    return Date.now() < expirationTime - 60000; // Check if expires in more than 1 minute
  } catch {
    return false;
  }
}

private decodeToken(token: string): any {
  const parts = token.split('.');
  if (parts.length !== 3) {
    throw new Error('Invalid token format');
  }
  
  const payload = parts[1];
  const decoded = atob(payload.replace(/-/g, '+').replace(/_/g, '/'));
  return JSON.parse(decoded);
}
```

#### Login Operation
```typescript
public login(credentials: LoginCredentials): Observable<AuthResponse> {
  this.updateAuthState({ loading: true, error: null });
  
  return this.wsService.request<LoginCredentials, AuthResponse>('auth', credentials).pipe(
    tap(response => {
      // Store tokens and user
      this.storeAuthData(response, credentials.rememberMe);
      
      // Update state
      this.setAuthState({
        isAuthenticated: true,
        user: response.user,
        tokens: response.tokens,
        loading: false,
        error: null
      });
      
      // Set up token refresh
      this.scheduleTokenRefresh();
      
      // Connect WebSocket
      this.connectWebSocket();
      
      // Navigate to dashboard
      this.router.navigate(['/dashboard']);
    }),
    catchError(error => {
      this.updateAuthState({
        loading: false,
        error: error.message || 'Login failed'
      });
      return throwError(() => error);
    })
  );
}
```

#### Registration Operation
```typescript
public register(data: RegistrationData): Observable<AuthResponse> {
  this.updateAuthState({ loading: true, error: null });
  
  return this.wsService.request<RegistrationData, AuthResponse>('register', data).pipe(
    tap(response => {
      // Don't auto-login after registration
      // Require email verification first
      this.updateAuthState({
        loading: false,
        error: null
      });
      
      // Navigate to verification page
      this.router.navigate(['/auth/verify-email'], {
        queryParams: { email: data.email }
      });
    }),
    catchError(error => {
      this.updateAuthState({
        loading: false,
        error: error.message || 'Registration failed'
      });
      return throwError(() => error);
    })
  );
}
```

#### Logout Operation
```typescript
public logout(): void {
  const token = this.getStoredToken();
  
  // Send logout message via WebSocket
  if (token) {
    this.wsService.send('logout', {});
  }
  
  // Always complete logout locally
  this.completeLogout();
}

private completeLogout(): void {
  // Clear stored data
  this.clearAuthData();
  
  // Reset state
  this.setAuthState({
    isAuthenticated: false,
    user: null,
    tokens: null,
    loading: false,
    error: null
  });
  
  // Clear token refresh
  this.clearTokenRefreshTimer();
  
  // Disconnect WebSocket
  this.wsService.disconnect();
  
  // Navigate to login
  this.router.navigate(['/login']);
}
```

#### Token Management
```typescript
private storeAuthData(response: AuthResponse, persistent: boolean = false): void {
  const storage = persistent ? localStorage : sessionStorage;
  
  storage.setItem(this.TOKEN_KEY, response.tokens.accessToken);
  
  if (response.tokens.refreshToken) {
    storage.setItem(this.REFRESH_TOKEN_KEY, response.tokens.refreshToken);
  }
  
  storage.setItem(this.USER_KEY, JSON.stringify(response.user));
}

private clearAuthData(): void {
  localStorage.removeItem(this.TOKEN_KEY);
  localStorage.removeItem(this.REFRESH_TOKEN_KEY);
  localStorage.removeItem(this.USER_KEY);
  sessionStorage.removeItem(this.TOKEN_KEY);
  sessionStorage.removeItem(this.REFRESH_TOKEN_KEY);
  sessionStorage.removeItem(this.USER_KEY);
}

private getStoredToken(): string | null {
  return localStorage.getItem(this.TOKEN_KEY) || 
         sessionStorage.getItem(this.TOKEN_KEY);
}

private getStoredRefreshToken(): string | null {
  return localStorage.getItem(this.REFRESH_TOKEN_KEY) || 
         sessionStorage.getItem(this.REFRESH_TOKEN_KEY);
}

private getStoredUser(): User | null {
  const userJson = localStorage.getItem(this.USER_KEY) || 
                   sessionStorage.getItem(this.USER_KEY);
  
  if (userJson) {
    try {
      return JSON.parse(userJson);
    } catch {
      return null;
    }
  }
  
  return null;
}

public getAccessToken(): string | null {
  return this.authStateSubject.value.tokens?.accessToken || null;
}
```

#### Token Refresh
```typescript
private refreshToken(): Observable<AuthTokens> {
  const refreshToken = this.getStoredRefreshToken();
  
  if (!refreshToken) {
    this.completeLogout();
    return throwError(() => new Error('No refresh token available'));
  }
  
  return this.wsService.request<any, AuthTokens>('refresh', { 
    refreshToken 
  }).pipe(
    tap(tokens => {
      // Update stored tokens
      const storage = localStorage.getItem(this.TOKEN_KEY) ? 
                     localStorage : sessionStorage;
      storage.setItem(this.TOKEN_KEY, tokens.accessToken);
      
      if (tokens.refreshToken) {
        storage.setItem(this.REFRESH_TOKEN_KEY, tokens.refreshToken);
      }
      
      // Update state
      this.updateAuthState({ tokens });
      
      // Reschedule refresh
      this.scheduleTokenRefresh();
    }),
    catchError(error => {
      // Refresh failed, logout
      this.completeLogout();
      return throwError(() => error);
    })
  );
}

private scheduleTokenRefresh(): void {
  this.clearTokenRefreshTimer();
  
  const token = this.getStoredToken();
  if (!token) return;
  
  try {
    const payload = this.decodeToken(token);
    const expirationTime = payload.exp * 1000;
    const refreshTime = expirationTime - Date.now() - 60000; // Refresh 1 minute before expiry
    
    if (refreshTime > 0) {
      this.tokenRefreshTimer = setTimeout(() => {
        this.refreshToken().subscribe();
      }, refreshTime);
    }
  } catch (error) {
    console.error('Failed to schedule token refresh:', error);
  }
}

private clearTokenRefreshTimer(): void {
  if (this.tokenRefreshTimer) {
    clearTimeout(this.tokenRefreshTimer);
    this.tokenRefreshTimer = undefined;
  }
}
```

#### User Operations
```typescript
public updateProfile(updates: Partial<User>): Observable<User> {
  return this.wsService.request<Partial<User>, User>('updateProfile', updates).pipe(
    tap(user => {
      // Update stored user
      const storage = localStorage.getItem(this.USER_KEY) ? 
                     localStorage : sessionStorage;
      storage.setItem(this.USER_KEY, JSON.stringify(user));
      
      // Update state
      this.updateAuthState({ user });
    })
  );
}

public changePassword(currentPassword: string, newPassword: string): Observable<void> {
  return this.wsService.request('changePassword', {
    currentPassword,
    newPassword
  });
}

public resetPassword(email: string): Observable<void> {
  return this.wsService.request('resetPassword', { email });
}

public confirmResetPassword(token: string, newPassword: string): Observable<void> {
  return this.wsService.request('confirmReset', { 
    token, 
    newPassword 
  });
}

public verifyEmail(token: string): Observable<void> {
  return this.wsService.request('verifyEmail', { token }).pipe(
    tap(() => {
      // Update user's email verified status
      const user = this.authStateSubject.value.user;
      if (user) {
        user.emailVerified = true;
        this.updateAuthState({ user });
      }
    })
  );
}

public resendVerificationEmail(): Observable<void> {
  return this.wsService.request('resendVerification', {});
}
```

#### Authorization Helpers
```typescript
public hasRole(role: string): boolean {
  const user = this.authStateSubject.value.user;
  return user?.roles?.includes(role) || false;
}

public hasAnyRole(roles: string[]): boolean {
  const user = this.authStateSubject.value.user;
  return roles.some(role => user?.roles?.includes(role)) || false;
}

public hasPermission(permission: string): boolean {
  const user = this.authStateSubject.value.user;
  return user?.permissions?.includes(permission) || false;
}

public hasAnyPermission(permissions: string[]): boolean {
  const user = this.authStateSubject.value.user;
  return permissions.some(perm => user?.permissions?.includes(perm)) || false;
}

public canAccess(resource: string): Observable<boolean> {
  return this.wsService.request<{ resource: string }, boolean>('canAccess', { resource });
}
```

#### WebSocket Integration
```typescript
private connectWebSocket(): void {
  const token = this.getStoredToken();
  if (token) {
    // Send authentication to WebSocket
    this.wsService.send('auth', { token });
    
    // Listen for auth responses
    this.wsService.on('auth_response')
      .pipe(takeUntil(this.destroy$))
      .subscribe(response => {
        if (!response.success) {
          // Authentication failed, logout
          this.completeLogout();
        }
      });
  }
}
```

#### State Management
```typescript
private setAuthState(state: AuthState): void {
  this.authStateSubject.next(state);
}

private updateAuthState(updates: Partial<AuthState>): void {
  const currentState = this.authStateSubject.value;
  this.authStateSubject.next({
    ...currentState,
    ...updates
  });
}

public getAuthState(): AuthState {
  return this.authStateSubject.value;
}
```

## Route Guards

### Auth Guard
```typescript
export const authGuard: CanActivateFn = (route, state) => {
  const authService = inject(AuthService);
  const router = inject(Router);
  
  return authService.isAuthenticated$.pipe(
    take(1),
    map(isAuthenticated => {
      if (isAuthenticated) {
        return true;
      }
      
      // Store intended URL for redirecting after login
      router.navigate(['/login'], {
        queryParams: { returnUrl: state.url }
      });
      return false;
    })
  );
};
```

### Role Guard
```typescript
export const roleGuard: CanActivateFn = (route, state) => {
  const authService = inject(AuthService);
  const router = inject(Router);
  
  const requiredRoles = route.data['roles'] as string[];
  
  if (!requiredRoles || requiredRoles.length === 0) {
    return true;
  }
  
  return authService.currentUser$.pipe(
    take(1),
    map(user => {
      if (user && requiredRoles.some(role => user.roles.includes(role))) {
        return true;
      }
      
      router.navigate(['/unauthorized']);
      return false;
    })
  );
};
```

## Usage Examples

### Login Component
```typescript
export class LoginComponent {
  loginForm = this.fb.group({
    email: ['', [Validators.required, Validators.email]],
    password: ['', [Validators.required, Validators.minLength(8)]],
    rememberMe: [false]
  });
  
  loading$ = this.authService.loading$;
  
  constructor(
    private fb: FormBuilder,
    private authService: AuthService,
    private route: ActivatedRoute
  ) {}
  
  onSubmit(): void {
    if (this.loginForm.valid) {
      this.authService.login(this.loginForm.value as LoginCredentials)
        .subscribe({
          next: () => {
            // Navigate to return URL or dashboard
            const returnUrl = this.route.snapshot.queryParams['returnUrl'] || '/dashboard';
            this.router.navigate([returnUrl]);
          },
          error: (error) => {
            // Error is handled in service
            console.error('Login failed:', error);
          }
        });
    }
  }
}
```

### Protected Route
```typescript
const routes: Routes = [
  {
    path: 'dashboard',
    component: DashboardComponent,
    canActivate: [authGuard]
  },
  {
    path: 'admin',
    component: AdminComponent,
    canActivate: [authGuard, roleGuard],
    data: { roles: ['admin', 'super-admin'] }
  }
];
```

## Testing

```typescript
describe('AuthService', () => {
  let service: AuthService;
  let wsService: jasmine.SpyObj<WebSocketService>;
  let router: jasmine.SpyObj<Router>;
  let snackBar: jasmine.SpyObj<MatSnackBar>;
  
  beforeEach(() => {
    const wsSpy = jasmine.createSpyObj('WebSocketService', ['send', 'request', 'on']);
    const routerSpy = jasmine.createSpyObj('Router', ['navigate']);
    const snackBarSpy = jasmine.createSpyObj('MatSnackBar', ['open']);
    
    TestBed.configureTestingModule({
      providers: [
        AuthService,
        { provide: WebSocketService, useValue: wsSpy },
        { provide: Router, useValue: routerSpy },
        { provide: MatSnackBar, useValue: snackBarSpy }
      ]
    });
    
    service = TestBed.inject(AuthService);
    wsService = TestBed.inject(WebSocketService) as jasmine.SpyObj<WebSocketService>;
    router = TestBed.inject(Router) as jasmine.SpyObj<Router>;
    snackBar = TestBed.inject(MatSnackBar) as jasmine.SpyObj<MatSnackBar>;
    
    localStorage.clear();
    sessionStorage.clear();
  });
  
  it('should login successfully', (done) => {
    const mockResponse: AuthResponse = {
      user: { id: '1', email: 'test@example.com' } as User,
      tokens: { accessToken: 'token123' } as AuthTokens,
      sessionId: 'session123'
    };
    
    wsService.request.and.returnValue(of(mockResponse));
    
    service.login({ 
      email: 'test@example.com', 
      password: 'password123' 
    }).subscribe(() => {
      expect(service.getAuthState().isAuthenticated).toBe(true);
      expect(service.getAuthState().user).toEqual(mockResponse.user);
      expect(router.navigate).toHaveBeenCalledWith(['/dashboard']);
      done();
    });
  });
  
  it('should handle login failure', (done) => {
    wsService.request.and.returnValue(
      throwError(() => ({ message: 'Invalid credentials' }))
    );
    
    service.login({ 
      email: 'test@example.com', 
      password: 'wrong' 
    }).subscribe({
      error: (error) => {
        expect(service.getAuthState().isAuthenticated).toBe(false);
        expect(service.getAuthState().error).toBe('Invalid credentials');
        done();
      }
    });
  });
  
  it('should logout and clear data', () => {
    // Set initial auth state
    localStorage.setItem('auth_token', 'token123');
    localStorage.setItem('auth_user', '{"id":"1"}');
    
    wsService.send.and.returnValue(undefined);
    
    service.logout();
    
    expect(localStorage.getItem('auth_token')).toBeNull();
    expect(localStorage.getItem('auth_user')).toBeNull();
    expect(service.getAuthState().isAuthenticated).toBe(false);
    expect(router.navigate).toHaveBeenCalledWith(['/login']);
  });
});
```

## Deliverables
- [ ] Auth service with login/logout functionality
- [ ] Token management and refresh
- [ ] User profile management
- [ ] Password reset flow
- [ ] Email verification
- [ ] Role-based authorization
- [ ] Route guards implemented
- [ ] WebSocket authentication
- [ ] Session persistence
- [ ] Unit tests passing

## Next Steps
- Create shared components (06.12)
- Update feature pages to use auth service
- Implement OAuth providers