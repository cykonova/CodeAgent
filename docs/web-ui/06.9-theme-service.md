# Phase 06.10: Theme Service

## Overview
Create a centralized service for managing application themes, including light/dark mode switching, theme persistence, and system preference detection.

## Objectives
- Manage theme state centrally
- Support light/dark theme switching
- Persist theme preference
- Detect system theme preference
- Provide reactive theme updates

## Prerequisites
- Phase 06.1 (Project Setup) completed
- Phase 06.2 (Theme System) completed
- Angular Material theming configured

## Implementation

### 1. Generate Service
```bash
ng generate service core/services/theme --skipTests=false
```

### 2. Theme Models

#### Theme Configuration
```typescript
export enum ThemeMode {
  Light = 'light',
  Dark = 'dark',
  System = 'system'
}

export interface ThemeConfig {
  mode: ThemeMode;
  primaryColor?: string;
  accentColor?: string;
  customProperties?: Record<string, string>;
}

export interface ThemeColors {
  primary: string;
  accent: string;
  warn: string;
  background: string;
  surface: string;
  text: string;
  textSecondary: string;
  divider: string;
}
```

### 3. Theme Service Implementation

#### Core Service Structure
```typescript
@Injectable({
  providedIn: 'root'
})
export class ThemeService {
  private readonly STORAGE_KEY = 'app-theme-preference';
  private readonly THEME_CLASS_PREFIX = 'theme-';
  
  private currentThemeSubject = new BehaviorSubject<ThemeMode>(ThemeMode.System);
  private isDarkModeSubject = new BehaviorSubject<boolean>(false);
  private themeColorsSubject = new BehaviorSubject<ThemeColors>(this.getLightColors());
  
  public currentTheme$ = this.currentThemeSubject.asObservable();
  public isDarkMode$ = this.isDarkModeSubject.asObservable();
  public themeColors$ = this.themeColorsSubject.asObservable();
  
  private mediaQuery = window.matchMedia('(prefers-color-scheme: dark)');
  private destroy$ = new Subject<void>();
  
  constructor(
    @Inject(DOCUMENT) private document: Document,
    private renderer: Renderer2
  ) {
    this.initializeTheme();
    this.setupSystemThemeListener();
  }
}
```

#### Theme Initialization
```typescript
private initializeTheme(): void {
  // Load saved preference
  const savedTheme = this.loadThemePreference();
  
  // Apply initial theme
  this.setTheme(savedTheme || ThemeMode.System);
  
  // Set up CSS custom properties
  this.updateCssVariables();
}

private loadThemePreference(): ThemeMode | null {
  const saved = localStorage.getItem(this.STORAGE_KEY);
  return saved as ThemeMode || null;
}

private saveThemePreference(theme: ThemeMode): void {
  localStorage.setItem(this.STORAGE_KEY, theme);
}
```

#### Theme Switching
```typescript
public setTheme(mode: ThemeMode): void {
  this.currentThemeSubject.next(mode);
  this.saveThemePreference(mode);
  
  const isDark = this.shouldUseDarkTheme(mode);
  this.applyTheme(isDark);
}

public toggleTheme(): void {
  const currentMode = this.currentThemeSubject.value;
  
  if (currentMode === ThemeMode.System) {
    // If system, switch to opposite of current
    const newMode = this.isDarkModeSubject.value ? ThemeMode.Light : ThemeMode.Dark;
    this.setTheme(newMode);
  } else {
    // Toggle between light and dark
    const newMode = currentMode === ThemeMode.Light ? ThemeMode.Dark : ThemeMode.Light;
    this.setTheme(newMode);
  }
}

private shouldUseDarkTheme(mode: ThemeMode): boolean {
  switch (mode) {
    case ThemeMode.Dark:
      return true;
    case ThemeMode.Light:
      return false;
    case ThemeMode.System:
      return this.mediaQuery.matches;
    default:
      return false;
  }
}
```

#### Theme Application
```typescript
private applyTheme(isDark: boolean): void {
  const previousDarkMode = this.isDarkModeSubject.value;
  
  // Update state
  this.isDarkModeSubject.next(isDark);
  
  // Update document class
  this.updateDocumentClass(isDark);
  
  // Update theme colors
  const colors = isDark ? this.getDarkColors() : this.getLightColors();
  this.themeColorsSubject.next(colors);
  
  // Update CSS variables
  this.updateCssVariables(isDark);
  
  // Emit theme change event
  if (previousDarkMode !== isDark) {
    this.emitThemeChangeEvent(isDark);
  }
}

private updateDocumentClass(isDark: boolean): void {
  const body = this.document.body;
  
  // Remove existing theme classes
  const existingClasses = Array.from(body.classList).filter(
    className => className.startsWith(this.THEME_CLASS_PREFIX)
  );
  existingClasses.forEach(className => {
    this.renderer.removeClass(body, className);
  });
  
  // Add new theme class
  const themeClass = `${this.THEME_CLASS_PREFIX}${isDark ? 'dark' : 'light'}`;
  this.renderer.addClass(body, themeClass);
  
  // Add Material theme class
  if (isDark) {
    this.renderer.addClass(body, 'dark-theme');
  } else {
    this.renderer.removeClass(body, 'dark-theme');
  }
}
```

#### CSS Variable Management
```typescript
private updateCssVariables(isDark: boolean = false): void {
  const root = this.document.documentElement;
  const variables = isDark ? this.getDarkVariables() : this.getLightVariables();
  
  Object.entries(variables).forEach(([key, value]) => {
    root.style.setProperty(key, value);
  });
}

private getLightVariables(): Record<string, string> {
  return {
    // Surface colors
    '--theme-background': '#fafafa',
    '--theme-surface': '#ffffff',
    '--theme-surface-variant': '#f5f5f5',
    
    // Text colors with opacity
    '--theme-text-primary': 'rgba(0, 0, 0, 0.87)',
    '--theme-text-secondary': 'rgba(0, 0, 0, 0.60)',
    '--theme-text-disabled': 'rgba(0, 0, 0, 0.38)',
    '--theme-text-hint': 'rgba(0, 0, 0, 0.38)',
    
    // State colors
    '--theme-hover': 'rgba(0, 0, 0, 0.04)',
    '--theme-selected': 'rgba(0, 0, 0, 0.08)',
    '--theme-activated': 'rgba(0, 0, 0, 0.12)',
    '--theme-pressed': 'rgba(0, 0, 0, 0.16)',
    
    // Divider
    '--theme-divider': 'rgba(0, 0, 0, 0.12)',
    
    // Shadows (adjusted for light theme)
    '--theme-shadow-sm': '0 1px 3px rgba(0,0,0,0.12), 0 1px 2px rgba(0,0,0,0.24)',
    '--theme-shadow-md': '0 3px 6px rgba(0,0,0,0.15), 0 2px 4px rgba(0,0,0,0.12)',
    '--theme-shadow-lg': '0 10px 20px rgba(0,0,0,0.15), 0 3px 6px rgba(0,0,0,0.10)',
    
    // Scrollbar
    '--theme-scrollbar-track': '#f1f1f1',
    '--theme-scrollbar-thumb': '#888',
    '--theme-scrollbar-thumb-hover': '#555'
  };
}

private getDarkVariables(): Record<string, string> {
  return {
    // Surface colors
    '--theme-background': '#303030',
    '--theme-surface': '#424242',
    '--theme-surface-variant': '#1e1e1e',
    
    // Text colors with opacity
    '--theme-text-primary': 'rgba(255, 255, 255, 1.00)',
    '--theme-text-secondary': 'rgba(255, 255, 255, 0.70)',
    '--theme-text-disabled': 'rgba(255, 255, 255, 0.50)',
    '--theme-text-hint': 'rgba(255, 255, 255, 0.50)',
    
    // State colors
    '--theme-hover': 'rgba(255, 255, 255, 0.08)',
    '--theme-selected': 'rgba(255, 255, 255, 0.16)',
    '--theme-activated': 'rgba(255, 255, 255, 0.24)',
    '--theme-pressed': 'rgba(255, 255, 255, 0.32)',
    
    // Divider
    '--theme-divider': 'rgba(255, 255, 255, 0.12)',
    
    // Shadows (adjusted for dark theme)
    '--theme-shadow-sm': '0 1px 3px rgba(0,0,0,0.24), 0 1px 2px rgba(0,0,0,0.48)',
    '--theme-shadow-md': '0 3px 6px rgba(0,0,0,0.30), 0 2px 4px rgba(0,0,0,0.24)',
    '--theme-shadow-lg': '0 10px 20px rgba(0,0,0,0.30), 0 3px 6px rgba(0,0,0,0.20)',
    
    // Scrollbar
    '--theme-scrollbar-track': '#2e2e2e',
    '--theme-scrollbar-thumb': '#6b6b6b',
    '--theme-scrollbar-thumb-hover': '#959595'
  };
}
```

#### System Theme Detection
```typescript
private setupSystemThemeListener(): void {
  // Listen for system theme changes
  fromEvent<MediaQueryListEvent>(this.mediaQuery, 'change')
    .pipe(takeUntil(this.destroy$))
    .subscribe(event => {
      if (this.currentThemeSubject.value === ThemeMode.System) {
        this.applyTheme(event.matches);
      }
    });
}

public getSystemTheme(): ThemeMode {
  return this.mediaQuery.matches ? ThemeMode.Dark : ThemeMode.Light;
}

public isSystemDarkMode(): boolean {
  return this.mediaQuery.matches;
}
```

#### Theme Colors Helper Methods
```typescript
private getLightColors(): ThemeColors {
  return {
    primary: '#1976d2',      // Material Blue 700
    accent: '#ff9800',       // Material Orange 500
    warn: '#f44336',         // Material Red 500
    background: '#fafafa',
    surface: '#ffffff',
    text: 'rgba(0, 0, 0, 0.87)',
    textSecondary: 'rgba(0, 0, 0, 0.60)',
    divider: 'rgba(0, 0, 0, 0.12)'
  };
}

private getDarkColors(): ThemeColors {
  return {
    primary: '#90caf9',      // Material Blue 200
    accent: '#ffb74d',       // Material Orange 300
    warn: '#ef5350',         // Material Red 400
    background: '#303030',
    surface: '#424242',
    text: 'rgba(255, 255, 255, 1.00)',
    textSecondary: 'rgba(255, 255, 255, 0.70)',
    divider: 'rgba(255, 255, 255, 0.12)'
  };
}

public getContrastColor(backgroundColor: string): string {
  // Simple contrast calculation
  const rgb = this.hexToRgb(backgroundColor);
  const brightness = (rgb.r * 299 + rgb.g * 587 + rgb.b * 114) / 1000;
  return brightness > 128 ? '#000000' : '#ffffff';
}

private hexToRgb(hex: string): { r: number; g: number; b: number } {
  const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
  return result ? {
    r: parseInt(result[1], 16),
    g: parseInt(result[2], 16),
    b: parseInt(result[3], 16)
  } : { r: 0, g: 0, b: 0 };
}
```

#### Theme Change Events
```typescript
private themeChangeSubject = new Subject<ThemeChangeEvent>();
public themeChange$ = this.themeChangeSubject.asObservable();

export interface ThemeChangeEvent {
  isDark: boolean;
  mode: ThemeMode;
  colors: ThemeColors;
  timestamp: Date;
}

private emitThemeChangeEvent(isDark: boolean): void {
  const event: ThemeChangeEvent = {
    isDark,
    mode: this.currentThemeSubject.value,
    colors: this.themeColorsSubject.value,
    timestamp: new Date()
  };
  
  this.themeChangeSubject.next(event);
  
  // Dispatch custom DOM event for non-Angular listeners
  const customEvent = new CustomEvent('themechange', { detail: event });
  this.document.dispatchEvent(customEvent);
}
```

#### Cleanup
```typescript
ngOnDestroy(): void {
  this.destroy$.next();
  this.destroy$.complete();
}
```

## Usage Examples

### Component Usage
```typescript
@Component({
  selector: 'app-header',
  template: `
    <mat-toolbar color="primary">
      <span>My App</span>
      <span class="spacer"></span>
      
      <button mat-icon-button 
              (click)="toggleTheme()" 
              [matTooltip]="themeTooltip$ | async">
        <mat-icon>{{ themeIcon$ | async }}</mat-icon>
      </button>
    </mat-toolbar>
  `
})
export class HeaderComponent {
  isDarkMode$ = this.themeService.isDarkMode$;
  
  themeIcon$ = this.isDarkMode$.pipe(
    map(isDark => isDark ? 'light_mode' : 'dark_mode')
  );
  
  themeTooltip$ = this.isDarkMode$.pipe(
    map(isDark => isDark ? 'Switch to light theme' : 'Switch to dark theme')
  );
  
  constructor(private themeService: ThemeService) {}
  
  toggleTheme(): void {
    this.themeService.toggleTheme();
  }
}
```

### Settings Component
```typescript
@Component({
  selector: 'app-theme-settings',
  template: `
    <mat-radio-group [(ngModel)]="selectedTheme" (change)="onThemeChange($event)">
      <mat-radio-button value="light">
        <mat-icon>light_mode</mat-icon>
        Light
      </mat-radio-button>
      
      <mat-radio-button value="dark">
        <mat-icon>dark_mode</mat-icon>
        Dark
      </mat-radio-button>
      
      <mat-radio-button value="system">
        <mat-icon>devices</mat-icon>
        System default
      </mat-radio-button>
    </mat-radio-group>
  `
})
export class ThemeSettingsComponent implements OnInit {
  selectedTheme: string = 'system';
  
  constructor(private themeService: ThemeService) {}
  
  ngOnInit() {
    this.themeService.currentTheme$.subscribe(theme => {
      this.selectedTheme = theme;
    });
  }
  
  onThemeChange(event: MatRadioChange): void {
    this.themeService.setTheme(event.value as ThemeMode);
  }
}
```

### Reactive Theme Colors
```typescript
@Component({
  selector: 'app-dashboard',
  template: `
    <div class="dashboard" [style.background-color]="backgroundColor$ | async">
      <div class="stats-card" [style.color]="textColor$ | async">
        <!-- Content -->
      </div>
    </div>
  `
})
export class DashboardComponent {
  backgroundColor$ = this.themeService.themeColors$.pipe(
    map(colors => colors.surface)
  );
  
  textColor$ = this.themeService.themeColors$.pipe(
    map(colors => colors.text)
  );
  
  constructor(private themeService: ThemeService) {}
}
```

## Testing

### Unit Test Requirements
```typescript
describe('ThemeService', () => {
  let service: ThemeService;
  let mockDocument: Document;
  let mockRenderer: Renderer2;
  
  beforeEach(() => {
    TestBed.configureTestingModule({
      providers: [
        ThemeService,
        { provide: DOCUMENT, useValue: document },
        Renderer2
      ]
    });
    
    service = TestBed.inject(ThemeService);
    localStorage.clear();
  });
  
  it('should initialize with system theme', () => {
    expect(service.currentTheme$.value).toBe(ThemeMode.System);
  });
  
  it('should toggle between light and dark themes', () => {
    service.setTheme(ThemeMode.Light);
    expect(service.isDarkMode$.value).toBe(false);
    
    service.toggleTheme();
    expect(service.isDarkMode$.value).toBe(true);
  });
  
  it('should persist theme preference', () => {
    service.setTheme(ThemeMode.Dark);
    expect(localStorage.getItem('app-theme-preference')).toBe('dark');
  });
  
  it('should apply CSS variables', () => {
    service.setTheme(ThemeMode.Dark);
    const root = document.documentElement;
    expect(root.style.getPropertyValue('--theme-background')).toBe('#303030');
  });
  
  it('should emit theme change events', (done) => {
    service.themeChange$.subscribe(event => {
      expect(event.isDark).toBe(true);
      expect(event.mode).toBe(ThemeMode.Dark);
      done();
    });
    
    service.setTheme(ThemeMode.Dark);
  });
  
  it('should detect system theme', () => {
    const mockMediaQuery = {
      matches: true,
      addEventListener: jasmine.createSpy()
    };
    
    spyOn(window, 'matchMedia').and.returnValue(mockMediaQuery as any);
    
    expect(service.isSystemDarkMode()).toBe(true);
  });
});
```

## Styling Integration

### Global Styles
```scss
// styles.scss
@use '@angular/material' as mat;

// Define theme-aware custom properties
:root {
  // These will be overridden by ThemeService
  --theme-background: #fafafa;
  --theme-surface: #ffffff;
  --theme-text-primary: rgba(0, 0, 0, 0.87);
}

// Use theme variables in components
.app-container {
  background-color: var(--theme-background);
  color: var(--theme-text-primary);
  transition: background-color 200ms ease, color 200ms ease;
}

// Smooth theme transitions
* {
  transition: background-color 200ms ease, 
              color 200ms ease,
              border-color 200ms ease;
}

// Custom scrollbar theming
::-webkit-scrollbar {
  width: 8px;
  height: 8px;
}

::-webkit-scrollbar-track {
  background: var(--theme-scrollbar-track);
}

::-webkit-scrollbar-thumb {
  background: var(--theme-scrollbar-thumb);
  border-radius: 4px;
  
  &:hover {
    background: var(--theme-scrollbar-thumb-hover);
  }
}
```

## Deliverables
- [ ] Theme service created with mode management
- [ ] Light/dark theme switching implemented
- [ ] System theme detection working
- [ ] Theme persistence in localStorage
- [ ] CSS variables updated dynamically
- [ ] Theme change events emitted
- [ ] Reactive observables for theme state
- [ ] Helper methods for colors
- [ ] Smooth theme transitions
- [ ] Unit tests passing

## Next Steps
- Implement Auth Service (06.11)
- Create additional shared services
- Build shared components (06.12)